var ae_data;

/**
 * Generate Alloy code
 * @param {*} graph 
 */
function exportAlloy(graph) {
    ae_data = {};
    var all = graph.getChildVertices(graph.getDefaultParent());
    all.forEach(c => {
        exportAlloyRec(c);
        /*console.log("=");
        console.log(c);*/
    });
    console.log("--DONE--");
    console.log(ae_data);
    var src;
    src = "/*\n * Automatically generated by the architectural editor\n *\n * This is an experimental feature (under development)\n";
    var currentdate = new Date(); 
    src += " * Generated by Arched v1.0a on "+currentdate.toDateString()+"\n */";
    src += exportAlloyTxt();
    console.log(src);
    return src;
}



function exportAlloyRec(component) {
    if(component.meta) {
        var clss = component.meta.class;
        if(clss==='Port') {

        }
        if(!ae_data[clss] && clss) {
            ae_data[clss] = [];
        }
        if(clss) {
            ae_data[clss].push(component);
        }
    }

    if(component.children) {
        component.children.forEach(c=> {
            exportAlloyRec(c);
        });
    }
}


/**
 * Export the diagram to Alloy
 */
function exportAlloyTxt() {
    //apply pre processing
    preprocess();

    //resulting source
    var src = "";

    //alloy model representation
    var ports = {};
    var components = {};
    var connections = new Set();
    var subComponents = {};


    var simpleSigs;

    Object.keys(ae_data).forEach(k=>{
        if(k==='IPort' || k==='OPort') { //TODO use metamodel
            if(!ports[k]) {
                ports[k] = [];
            }
            ae_data[k].forEach(e=> {
                ports[k].push(e.value);
            });
        } else {
            ae_data[k].forEach(e=> {

                if(!components[e.value]) {
                    components[e.value] = {};
                }

                components[e.value].extends = k;
                components[e.value].ports = {};

                if(k==="Leaf" || k==="Composite") {
                    var pn = 1;
                    if(ae_data["IPort"]) {
                        ae_data["IPort"].filter(p=>p.parent.value===e.value).forEach(p=> {
                            var pkind = "input";//TODO: use metamodel
                            if(!components[e.value].ports[pkind]) { 
                                components[e.value].ports[pkind] = [];
                            }
                            p.pname = "i"+pn++;
                            components[e.value].ports[pkind].push(p.pname);
                        });
                    }
                    if(ae_data["OPort"]) {
                        pn=1;
                        ae_data["OPort"].filter(p=>p.parent.value===e.value).forEach(p=> {
                            var pkind = "output";
                            if(!components[e.value].ports[pkind]) { //TODO: use metamodel
                                components[e.value].ports[pkind] = [];
                            }
                            p.pname = "o"+pn++;
                            components[e.value].ports[pkind ].push(p.pname);
                        });
                    }                    
                }

            });
        }
    });

    Object.keys(ae_data).forEach(k=>{
        if(k==='IPort' || k==='OPort') {
            ae_data[k].forEach(p=> {
                p.edges.forEach(e=>{
                    connections.add(e.source.parent.value+"."+e.source.pname+"->"+e.target.parent.value+"."+e.target.pname);
                });
            });
        }
    });



    

    Object.keys(ae_data).forEach(k=>{
        if(k==='Leaf' || k==='Composite') {
            ae_data[k].forEach(p=> {
                if(p.parent.value) {
                    console.log(p.value, p.parent.value);
                    if(!subComponents[p.parent.value]) {
                        subComponents[p.parent.value] = [];
                    }
                    subComponents[p.parent.value].push(p.value);
                }
            });
        }
    });


    //code generation

    var separator = '';
    //create ports
    for(k in ports) {
        src += "one sig ";
        ports[k].forEach(p=>{
            src += separator + p;
            separator = ', ';
        });
        src += " extends "+k+" { }\n";
    }

    src += "\n";

    //create sigs
    for(k in components) {
        var v = components[k];
        src += "one sig " + k +" extends " +  v.extends + " { ";

        separator = '';
        for(pk in v.ports) {
            src += separator + " disj ";
            src += v.ports[pk].reduce( (a,b) => a+","+b );
            src += " : " + pk;
            separator = ', ';
        }
        
        src+="}\n";
    }

    src += "\n";

    //create connections
    src += "fact connections {\n";
    if(connections.size>0) {
        src += "    to = ";
        separator = '';
        connections.forEach(v => {
            src += "    " + separator + v + "\n";
            separator = "+ ";
        });
    }
    
    src += "}\n";

    src += "\n";

    //create subcomponents

    src += "fact subComponents {\n";
    separator = '';
    Object.keys(subComponents).forEach(k=> {
        src += k+".subs = ";
        subComponents[k].forEach(c => {
            src += separator + c;
            separator = "+ ";
        })
        src += "\n";
    });
    src += "}\n";


    //run
    src += "\n";
    src+= "run { }"

    return src;
}

function preprocess() {
    var pc=0;
    if(ae_data['IPort']) {
        ae_data['IPort'].forEach(p=>{
            if(!p.value) {
                p.value='p'+pc++;
            }
        });
    }
    if(ae_data['OPort']) {
        ae_data['OPort'].forEach(p=>{
            if(!p.value) {
                p.value='p'+pc++;
            }
        });
    }    
}





/**
 * Export the model to JSON. Can be loaded later.
 * @param {*} editor 
 * @param {*} cell 
 */
function exportToJson(editor, cell) {
    //create the representation
    var json = {};

    //add meta information
    json.descriptor = {};
    json.descriptor.file_type="emdl";
    json.descriptor.version="2.0";
    json.descriptor.description="emucharts model";
    json.descriptor.chart_name="none";
    json.descriptor.serial=serial;

    //initialize chart variables
    json.chart = {};
    json.chart.states=[];
    json.chart.transitions=[];
    json.chart.initial_transitions=[];
    json.chart.variables=[];
    json.chart.constants=[];
    json.chart.datatypes=[];
    var model = _graph.getModel();

    Object.keys(model.cells).forEach(function (k) {
        if(model.cells[k].value && !model.cells[k].edge) {

            var tcell = model.cells[k];
            console.log("Saving ", tcell);
            var s = {};
            s.id=tcell.id;
            if(tcell.parent && tcell.parent.meta && tcell.parent.meta.role && tcell.parent.meta.role==='port') {
                s.id = tcell.parent.id;
            }
            s.value=tcell.value;
            s.x = tcell.geometry.x;
            s.y = tcell.geometry.y;
            s.width = tcell.geometry.width;
            s.height = tcell.geometry.height;

            if(tcell.meta) {
                if(tcell.meta.specification) {
                    s.specification = tcell.meta.specification;
                }
                if(tcell.meta.iokind) {
                    s.iokind = tcell.meta.iokind;
                }
                if(tcell.meta.kind) {
                    s.kind = tcell.meta.kind;
                }
                if(tcell.meta.class) {
                    s.class = tcell.meta.class;
                }
                if(tcell.meta.direction) {
                    s.direction = tcell.meta.direction;
                }
            }

            //handle parent properties
            if(tcell.parent.meta) {
                if(tcell.parent.meta.position) {
                    s.position = tcell.parent.meta.position;
                }
                if(tcell.parent.meta && tcell.parent.meta.role) {
                    s.role = tcell.parent.meta.role;
                }

                if(tcell.parent.meta.role && tcell.parent.meta.role === 'port') {
                    //parent of port label is a rectangle with no value
                    s.parent=tcell.parent.parent.value;
                } else {
                    s.parent=tcell.parent.value;
                }

                if(tcell.parent.meta.position) {
                    s.position = tcell.parent.meta.position;
                }
                if(tcell.parent.meta.direction) {
                    s.direction = tcell.parent.meta.direction;
                }
            }
            s.children=[];

            //Check children
            if(tcell.children) {
                console.log("I'll ignore ", tcell.children);
                tcell.children.forEach(c=>{
                    if(c.meta && c.meta instanceof PortMeta) {
                        s.children.push(c.id);
                        var tport = {};
                        tport.id = c.id;
                        tport.x = c.geometry.x;
                        tport.y = c.geometry.y;
                        tport.width = c.geometry.width;
                        tport.height = c.geometry.height;
                        tport.kind = "port";
                        tport.class= c.meta.klass;
                        tport.io = c.meta.iokind;
                        tport.position = c.meta.position;
                        json.chart.states.push(tport);
                    }
                })

                tcell.children.forEach(function (c) {
                    if(c.value) {
                        s.children.push(c.id);
                    }
                    if(c.meta && c.meta.role && c.meta.role==='port') {
                        s.children.push(c.id);
                    }
                });
            }


            //port cell is ignored, and accessed through label
            if(tcell.parent && tcell.parent.meta instanceof PortMeta) {
                s.kind = "port";
                s.iokind = tcell.parent.meta.iokind;
                s.klass = tcell.parent.meta.klass;
            }

            if(tcell.meta && tcell.meta instanceof PortMeta) {
                s.kind = "port";
            }

            json.chart.states.push(s);
        }

        //edges
        if(model.cells[k].edge) {
            console.log("EDGE ",model.cells[k],model.cells[k].source.meta instanceof PortMeta);
            var t = {};
            t.id = model.cells[k].id;
            t.name = model.cells[k].value;

            var s = {};
            s.id = model.cells[k].source.id;
            if(model.cells[k].source.meta instanceof PortMeta) {
                //s.id = model.cells[k].source.children[0].id;//....not ok
            }
            t.source = s;

            s = {};
            s.id = model.cells[k].target.id;
            if(model.cells[k].target.meta instanceof PortMeta) {
                //s.id = model.cells[k].target.children[0].id;
            }
            t.target = s;
            json.chart.transitions.push(t);
        }
    });

    if(_metamodel) {
        json.metamodel = _metamodel;
    }

    json = JSON.stringify(json);
    console.log(json);

    var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json);
    var dlAnchorElem = document.getElementById('downloadAnchorElem');
    dlAnchorElem.setAttribute("href", dataStr);
    dlAnchorElem.setAttribute("download", "model.json");
    dlAnchorElem.click();

    //TODO show window ?
    /*
    var textarea = document.createElement('textarea');
    textarea.style.width = '400px';
    textarea.style.height = '400px';
    var enc = new mxCodec(mxUtils.createXmlDocument());
    var node = enc.encode(editor.graph.getModel());
    textarea.value = mxUtils.getPrettyXml(node);
    showModalWindow(graph, 'XML', textarea, 410, 440);*/
}


/**
 * Aux method for model import
 * @param {*} states 
 * @param {*} cell 
 * @param {*} parent 
 */
function processCell(states, cell, parent) {
    if(!cell || cell.drawn) {
        return;
    }
    if(cell.kind ==='port') {
        //component.meta.class
        if(parent) {
            var x = 0.1;
            var y = 0;
            initCellPorts(cell);
            var rotation = "0";
            cell.meta = new PortMeta();

            switch(cell.position) {
                case 'l': cell.meta.ports_left++;x = 0; rotation="180"; break;
                case 'r': cell.meta.ports_right++;x = 1; break;
                case 'b': cell.meta.ports_bottom++; y = 1; rotation="90"; break;
                case 't': cell.meta.ports_top++; rotation="-90"; y = 0; break;
            }

            if(cell.iokind) {
                cell.meta.iokind = cell.iokind;
            }
            if(cell.kind) {
                cell.meta.kind = cell.kind;
            }
            var par = {};
            par.kind = cell.iokind;
            par.klass = cell.klass;
            par.name = cell.iokind;
            par.k = "port";
            x = cell.x;
            y = cell.y;

            var img = 'editors/images/rectangle.gif';
            if(cell.io) {
                if(cell.io === 'I') {
                    img = 'images/port_in.svg;shape=image';
                } else if(cell.io === 'O') {
                    img = 'images/port_out.svg;shape=image';
                }
            }

            //BUG: when loading, ports are not represented with images
            //TODO: labels

            var port = _graph.insertVertex(parent, cell.id, null, x, y, 16, 16,'image='+img+';align=right;imageAlign=right;verticalLabelPosition=bottom;verticalAlign=top;rotation='+rotation, true);
            port.meta = new PortMeta();
            port.meta.kind="port";
            port.meta.klass=cell.class;
            port.meta.iokind=cell.io;
            port.meta.position = cell.position;
            port.geometry.offset = new mxPoint(-6, -8);
            updateComponentPorts(_graph, parent);


    /* //labels
            var port = graph.insertVertex(cell, id, null, x, y, 16, 16,'image='+img+';align=right;imageAlign=right;verticalLabelPosition=bottom;verticalAlign=top;rotation='+rotation, true);
            port.meta= new PortMeta();
            port.meta.setPosition(pos);
        
            var lblv = graph.insertVertex(port, id, lbl, x*cell.meta.ports[pos], y, 0, 0,
                'align=right;imageAlign=right;resizable=0;dragEnabled=0;', false);
            lblv.meta = new Meta();
            lblv.meta.role = 'lbl';
        
            if(params) {
                if(params.name) {
                    //lblv.meta.klass = params.name;
                    port.meta.klass = params.name;
                }
                if(params.kind) {
                    console.log("SETTING KIND",params);
                    port.meta.setIOKind(params.kind);
                }
            }
        
            lblv.setConnectable(true);
            port.geometry.offset = new mxPoint(-6, -8);
        
            updateComponentPorts(graph, cell);
*/





            // --------------- END TODO






            
            //addPort(_graph,parent,cell.x,cell.y, cell.position, cell.id, cell.value, par);
        } else {
            return;
        }
    } else {
        if(parent || !cell.parent) {
            var v1 = _graph.insertVertex(parent, cell.id, cell.value, cell.x, cell.y, cell.width, cell.height);
            v1.meta = new CellMeta();
        } else {
            return;
        }
    }
    if(parent && v1) {
        v1.parent=parent;
        _graph.addCell(v1, parent);
        //parent.children.push(v1);
    }
    cell.drawn = true;
    if(cell.spec && v1) {
        v1.spec = cell.spec;
        v1.meta.spec = cell.spec;
        processOverlay(v1,_graph);
    }

    if(cell.kind && v1) {
        v1.k = cell.kind;
        v1.meta.kind = cell.kind;
    }

    if(cell.iokind && v1) {
        v1.meta.iokind = cell.iokind;
    }


    if(cell.class && v1) {
        v1.meta.class=cell.class;
    }

    if(cell.direction && v1) {
        v1.meta.direction=cell.direction;
    }

    if(cell.role && v1) {
        v1.r = cell.role;
        v1.meta.role = cell.role;
    }

    if(cell.children) {
        cell.children.forEach(function (c) {
            var tc = states.filter(function f(e) {return e.id == c})[0];
            processCell(states, tc, v1);
        });
    }
}


/**
 * Create the visual representation from an emdl file. 
 * Used to open a model
 * @param {*} json 
 */
function buildModel(json) {
    console.log(json);
    var parent = _graph.getDefaultParent();
    var model = _graph.getModel();
    model.beginUpdate();
    //draw all edges
    try {
        if(json.metamodel) {
            _metamodel = json.metamodel;
            processToolbox();
        }
        //add root vertexes
        json.chart.states.forEach(function(f) {
            processCell(json.chart.states, f, null);            
        });

        //edges
        json.chart.transitions.forEach(function(t) {
            var sv = model.getCell(t.source.id);
            var tv = model.getCell(t.target.id);
            var e1 = _graph.insertEdge(parent, t.id, t.value, sv, tv);
        });
        serial = json.descriptor.serial;

    }
    finally
    {
        model.endUpdate();
    }
}