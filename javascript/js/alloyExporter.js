
var ae_data;


function exportAlloy(graph) {
    ae_data = {};
    var all = graph.getChildVertices(graph.getDefaultParent());
    all.forEach(c=> {
        exportAlloyRec(c);
        /*console.log("=");
        console.log(c);*/
    });
    console.log("--DONE--");
    console.log(ae_data);
    var src;
    src = "/* Automatically generated by the architectural editor\n  This is an experimental feature still under development\n*/\n\n"
    src += exportAlloyTxt();
    console.log(src);
    return src;
}

function exportAlloyRec(component) {
    console.log(component);
    if(component.meta) {
        var clss = component.meta.class;
        console.log("CLASS:: " + clss);
        if(!ae_data[clss] && clss) {
            ae_data[clss] = [];
        }
        if(clss) {
            ae_data[clss].push(component);
        }
    }

    if(component.children) {
        component.children.forEach(c=> {
            exportAlloyRec(c);
        });
    }
}

//TODO: ports
function exportAlloyTxt() {
    var src = "";
    Object.keys(ae_data).forEach(k=>{
        src += "one sig ";
        ae_data[k].forEach(e=> {
            parent = k;
            src += e.value+", ";
            console.log(e.meta.kind);
            console.log(e.meta.io);
        });
        src+=" extends "+k+"{}\n";
        if(k==="Leaf") {
            
        } else if(k==="Composite") {

        }

    });
    return src;
}


/*
open metamodel

// MODEL

// these name should be generated automatically by the graphical tool, not decided by the user
one sig p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 extends IPort {}
one sig p11, p12, p13, p14, p15, p16, p17, p18, p19 extends OPort {}

// all names here should be decided by the user
one sig A extends Leaf { disj i1 : input, disj o1 : output }
one sig B extends Leaf { disj i1 : input, disj o1 : output }
one sig C extends Leaf { disj i1, i2 : input, disj o1 : output }
one sig D extends Leaf { disj i1 : input, disj o1 : output }
one sig E extends Leaf { disj i1 : input, disj o1 : output }
one sig F extends Composite { disj i1, i2 : input, disj o1, o2 : output } 
one sig Sys extends Composite { disj i1, i2 : input, disj o1, o2 : output }

// here there are two facts, but only one would be OK, I split them for a better reading

fact connections { 
to =
  Sys.i1->F.i1
+ Sys.i2->F.i2
+ F.i1->A.i1 
+ F.i1->B.i1
+ A.o1->C.i1
+ B.o1->C.i2
+ C.o1->F.o1
+ B.o1->F.o2
+ F.o1->D.i1
+ F.o2->E.i1
+ D.o1->Sys.o1
+ E.o1->Sys.o2
}

fact subComponents {
	F.subs = A + B + C
	Sys.subs = D + E + F
}
run {}*/